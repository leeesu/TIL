### 💡 시작하며

자바의 가장 기본적인 개념 중 하나인 객체지향에 대해서 전반적으로 개념들을 정리하고자 한다.

### 👩‍🚀 Think

객체지향 프로그래밍을 접하게 되면 가장 먼저 접하게 되는 단어는 추상화하다라는 단어다. 전혀 와닿지 않는 단어다. 추상화 시키다의 사전적 의미는 표준대국어사전에 따르면 

<aside>
✅ *【(…을)】 추상적인 것으로 되다. 또는 그렇게 만들다.*

</aside>

추상화화다의 의미를 찾았는데 추상적인 것으로 되다…라는 단어가 나온다. 그래서 다시 네이버 컴퓨터인터넷 IT용어 대사전에서 ‘추상화’ 검색을 했다.

<aside>
✅ 컴퓨터 과학 분야에서 주어진 문제나 시스템의 복잡도를 **단순화하여 인식하기 쉽게 만드는 개념화 작업.핵심 요소를 잘 파악하여 필요 이상으로 상세, 복잡한 요소들을 결합하거나 단순화하고, 속성의 일부분만으로 주어진 대상을 간결하고 명확하게 표현**한다. 복잡도를 관리하는 핵심 기술이라고 할 수 있다.

방식에 따라 데이터 추상화(data abstraction)와 절차 추상화(procedural abstraction)로 나뉜다. **데이터 추상화는 하나의 데이터와 관련된 조작 및 표현 유형을 결합하는 방식이다. 예를 들어, 학번, 이름, 생일, 연락처, 주소, 성적 등 모든 항목을 언급하기보다 ‘학생’이라는 항목(개체)으로 결합하여 추상화한다.** 절차 추상화는 세부적인 실행 절차를 단순화하는 방식이다. 예를 들어, **라면 조리를 설명할 때마다 가스레인지 켜기, 냄비에 물 넣기, 물 끓이기, 라면과 스프 넣기 등 세부 절차를 모두 언급하면 너무 복잡하다. 따라서 이를 ‘라면 조리’라고 추상화**하여 간단하게 표현하는 것이다.

**[네이버 지식백과]** 추상화 [abstraction, 抽象化] (IT용어사전, 한국정보통신기술협회)

</aside>

- 데이터 추상화는 하나의 데이터와 관련된 조작 및 표현 유형을 결합하는 방식 → 대충 원래 알고 있던 개념의 영역까지 접근 했다.

다른 사전에서 추상화에 대해서 다시 찾아봤다.

<aside>
✅ **추상하다 抽象하다 :**
여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하다.

</aside>

- 가장 기존에 알고 있던 추상화하다의 의미에 근접한 설명 같다.
- 객체지향 프로그래밍을 할때 가장 먼저하는것은 **공통되는 특징을 가진 객체들을 하나로 묶는 것**이다.
    - 예를 들어 자동차라고 하면 자동차는 백미러, 엔진, 의자, 핸들 등 여러 속성이 모여서 이루어진다.
    - 객체를 정의한 다음에 객체가 제공하는 기능들을 구현하고, 각 객체가 제공하는 기능들 간의 소동을 통해 협력을 구현하는게 객체지향 프로그래밍의 추상화이며 이 객체를 생성하기 위해 변수와(속성), 기능(메서드)를 정의하는게 클래스다.

---

## 1. 객체지향 프로그래밍이란?

객체 지향 프로그래밍(OOP: Object-Oriented Programming)은 우리가 살고 있는 실제 세계가 객체(Object)들로 구성되어 있는 것과 비슷하게, 소프트웨어도 객체로 구성하는 방법이다. 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체를 만들고, 그 객체간의 유기적인 상호작용을 통해 로직을 구성하는 방법이다.

한마디로 **조립식 프로그래밍**이며, 객체를 조립하여 전체의 프로그램으로 만드는 거 라고 볼 수 있다.

쉽게 말해 가능한 모든 물리적, 논리적 요소를 객체로 만들려는 것이 객체지향 프로그래밍, 더욱 세분화하여 정보의 디테일을 살리는 것

예) 자동차(프로그램) = 몸체(객체) + 핸들(객체) + 브레이크(객체)

**객체는 속성(색상, 나이)과 동작(운행하다, 멈추다)으로 구성**되어 있으며, 자바에서는 이 속성과 동작을 필드(field), 동작(Method)라고 부른다. **객체 모델링은 속성과 동작을 구분하여 필드와 메소드로 정의**하는 과정이다. 

## 2. 객체 지향 프로그램의 장, 단점

✔ **장점**

- 코드 재사용이 용이하다. :: **재사용성**
    - 기존에 만들어진 클래스를 재사용 할 수 있고, 상속을 통해 확장 가능
- 유지보수가 편리하다 :: **유지보수**
    - 수정해야 할 부분이 클래스 내부에 있으므로 해당 부분만 수정하면 된다.
- 대형 프로젝트에 적합
    - 클래스 단위로 모듈화시켜서 개발한다. → 업무 분담의 편리성이 향상 된다.
- 코드의 중복을 제거하여 코드의 불일치로 인한 오작동을 미연에 방지 할 수 있다.  :: **코드의 중복제거**

**✔ 단점**

- 처리속도가 상대적으로 느리다.
- 객체의 수가 증가하면 → 용량이 커질 수 있다.
- 설계시 많은 시간과 노력이 필요하다
    - 좋은 객체를 만드는 것을 다른말로 설계를 잘 하는 법이라고 할 수 있는데 좋은 설계는 현실을 잘 반영해야 한다.

## 3. 객체지향 프로그래밍에서 클래스란?

- 객체를 정의해 놓은 것이며, 객체를 생성하는데 사용한다.(인스턴스 화)
- 클래스를 프로그래밍적 언어로 표현하자면 어떠한 객체의 변수(variable), 메소드(method)의 집합이라고 표현 할 수 있다.
    - 변수-속성(Property) : 멤버변수(member variable), 특성(attribute), 필드(field), 상태(state)
    - 메소드-기능(Function) : 메서드(method), 행위(behavior), 함수(function)
- 클래스는 객체를 만들기위한 **설계도이자 틀**이라고 볼 수 있다.
- 프로그램을 만들려면 여러 객체가 필요하고, 여러 객체를 만들려면 객체별 클래스가 필요하다.
- 클래스로 객체를 만드는 것을 ‘인스턴스화’라고 한다.

## 4. 객체지향 프로그래밍의 특징

1. **추상화(Abstarction)**

추상화는 실제 세상을 객체화 하는게 아니라, 필요한 정보만을 중심으로 간소화하는 것을 의미한다. 

1. **캡슐화(Encapsulation)**
- 데이터(속성)과 데이터를 처리하는 함수를 하나로 묶어 각 객체의 독립적인 역할을 보장한다.
- 캡슐화된 객체의 세부 내용이 외부에 은폐(정보은닉)되어, 변경이 발생할 때 오류의 파급효과가 적다. 캡슐화된 객체들은 재사용이 용이하다.
    - 정보은닉 : 객체의 내부 구현을 숨김으로써 객체가 반드시 정해진 메소드를 통해 상호작용 하도록 한다.
- 속성과 기능을 하나의 캡슐처럼 만들어서 데이터를 외부로 부터 ‘보호’하는 것.
- 데이터은닉(외부에 필요한 부분만 노출), 데이터 보호(외부로부터 클래스에 정의된 속성과 기능 보호)
    - 캡슐화를 수행하려면, 일부 필드는 private으로 정의하고 일부는 public으로 정의해야 한다.
    - 필드를 private으로 정의하면 클래스 외부에서 엑세스 할 수 없다.
1. **상속성(Inheritance)**
- 이미 정의된 상위 클래스(부모 클래스)의 모든 속성과 연산을 하위 클래스가 물려받는 것이다.
- 상속성을 이용하면 하위 클래스는 상위 클래스의 모든 속성과 연산을 자신의 클래스 내에서 다시 정의하지 않고서도 즉시 자신의 속성으로 사용할 수 있다.
- 부모 클래스의 속성과 기능을 그대로 물려받아 사용할 수 있고, 기능의 일부분을 변경해야 할 경우 상속받은 자식 클래스에서 해당하는 부분만 수정해서 사용 할 수 있다.
- 비효율적인 코드의 중복을 피할 수 있다.
1. **다형성 (Polymorphism)**
- 사전적 의미 ' 다양한 형태로 나타날 수 있는 능력이다.
- 같은 기능(메소드)를 호출하더라도 객체에 따라 다르게 동작하는 것을 의미한다.
- 상위 클래스의 동작을 하위클래스에서 다시 정의하여 사용하는 것 또한 다형성으로 볼 수 있다.

☘ 예를 들어 모닝을 운전하다가 소나타를 운전한다고 했을때 운전자(client)는 자동차의 내부구조를 알 필요가 없고, 자동차의 역할만 알고 있으면 된다. 내부구조가 변경되더라고도 영향받지 않고 운전

## 5. 객체지향적 설계원칙

각각의 원칙의 앞글자를 따서 SOLID 원칙이라고 부른다.

- **단일 책임의 원칙(SRP : Single Responsibility Principle)**
    - 클래스는 하나의 책임만을 가진다.
- **개방 폐쇄의 원칙(OCP : Open-Closed Principle)**
    - 확장에는 열려있고, 변경에는 닫혀있어야 한다.
    - 추가사항이 발생하더라도 기존 구성요소는 수정이 일어나지 말아야 한다.
- **리스 코브 치환의 원칙(LSP : Liskov Substitution Principle)**
    - 상위 타입의 객체는 언제나 하위 타입의 객체로 치환할 수 있어야 한다.
    - 즉, 상속은 is-A 관계일 때만 상속관계로 존재해야 한다.
- **인터페이스 분리의 원칙(ISP : Interface Segregation Principle)**
    - 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다.
    - 범용 인터페이스를 만들지 말고 적정한 기능에 따라 분리시켜야 한다.
- **의존성 역전의 원칙(DIP : Dependency Inversion Principle)**
    - 고수준 모듈은 저수준 모듈에 직접 의존해서는 안된다.
    - 클래스를 참조할 때 구체적인 클래스보다는 인터페이스나 추상 클래스와 의존 관계를 맺도록 해야 느슨하고 유연한 시스템이 된다.
    - 의존 관계를 맺을 때, 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 변화가 거의 없는 것에 의존하라는 원칙.

## 🔗 Reference

[https://velog.io/@jacob0122/객체-지향-프로그래밍이란](https://velog.io/@jacob0122/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80)

[https://jimmyhouse.tistory.com/14](https://jimmyhouse.tistory.com/14)

[https://88240.tistory.com/432](https://88240.tistory.com/432)

[https://clairdelunes.tistory.com/14](https://clairdelunes.tistory.com/14)

[https://blog.naver.com/rlaghdrl333/222480588331](https://blog.naver.com/rlaghdrl333/222480588331)

[https://mentum.tistory.com/478](https://mentum.tistory.com/478)